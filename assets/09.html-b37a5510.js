import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as a,e as r}from"./app-988496f1.js";const i={},d=r('<h2 id="_1-定义" tabindex="-1"><a class="header-anchor" href="#_1-定义" aria-hidden="true">#</a> 1.定义</h2><p>要用的属性不存在，需要通过已有的属性计算得来。</p><h2 id="_2-原理" tabindex="-1"><a class="header-anchor" href="#_2-原理" aria-hidden="true">#</a> 2.原理</h2><p>底层借助<code>Object.defineProperty()</code>提供的 getter 和 setter。</p><h2 id="_3-get-函数什么时候执行" tabindex="-1"><a class="header-anchor" href="#_3-get-函数什么时候执行" aria-hidden="true">#</a> 3.get 函数什么时候执行</h2><ul><li><p>初次读取时会执行一次。</p></li><li><p>当依赖的数据发生改变时会被再次调用。</p></li></ul><h2 id="_4-优势" tabindex="-1"><a class="header-anchor" href="#_4-优势" aria-hidden="true">#</a> 4.优势</h2><p>与 methods 实现相比，内部有缓存机制（可以 <strong>复用</strong> ），效率更高，调试方便。</p><h2 id="_5-备注" tabindex="-1"><a class="header-anchor" href="#_5-备注" aria-hidden="true">#</a> 5.备注</h2><ul><li><p>计算属性最终会出现在 vm 上，直接读取使用即可。</p></li><li><p>如果计算属性要被修改，那必须写 set 函数去响应式修改，且 set 中要引起计算属性计算时 <strong>所依赖的数据</strong> 发生改变。</p></li><li><p>如果确定计算属性只读取不修改，可以省略 getter 和 setter，把定义的计算属性对象写成 <strong>函数</strong> 形式。</p></li></ul>',10),h=[d];function n(s,o){return t(),a("div",null,h)}const _=e(i,[["render",n],["__file","09.html.vue"]]);export{_ as default};
