import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as a,e as r}from"./app-e8072a92.js";const i={},l=r('<h2 id="一-定义" tabindex="-1"><a class="header-anchor" href="#一-定义" aria-hidden="true">#</a> （一）定义</h2><ul><li>要用的属性不存在，需要通过已有的属性计算得来</li></ul><h2 id="二-原理" tabindex="-1"><a class="header-anchor" href="#二-原理" aria-hidden="true">#</a> （二）原理</h2><ul><li>底层借助 <code>Object.defineProperty()</code> 提供的 getter 和 setter</li></ul><h2 id="三-get-函数什么时候执行" tabindex="-1"><a class="header-anchor" href="#三-get-函数什么时候执行" aria-hidden="true">#</a> （三）get 函数什么时候执行</h2><ul><li>初次读取时会执行一次</li><li>当依赖的数据发生改变时会被再次调用</li></ul><h2 id="四-优势" tabindex="-1"><a class="header-anchor" href="#四-优势" aria-hidden="true">#</a> （四）优势</h2><ul><li>与 methods 实现相比，内部有缓存机制（可以 <strong>复用</strong> ），效率更高，调试方便</li></ul><h2 id="五-备注" tabindex="-1"><a class="header-anchor" href="#五-备注" aria-hidden="true">#</a> （五）备注</h2><ul><li>计算属性最终会出现在 vm 上，直接读取使用即可</li><li>如果计算属性要被修改，那必须写 set 函数去响应式修改，且 set 中要引起计算属性计算时 <strong>所依赖的数据</strong> 发生改变</li><li>如果确定计算属性只读取不修改，可以省略 getter 和 setter，把定义的计算属性对象写成 <strong>函数</strong> 形式</li></ul>',10),d=[l];function h(n,s){return t(),a("div",null,d)}const u=e(i,[["render",h],["__file","09.html.vue"]]);export{u as default};
