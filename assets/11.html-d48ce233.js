import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as r,c as d,a,b as t,d as i,w as c,e as n}from"./app-d3eba0aa.js";const p="/assets/网络01-3e654e99.png",u="/assets/网络02-3efff028.png",h="/assets/网络03-b5c18027.png",m="/assets/网络04-fd62f930.png",b="/assets/网络05-a160308a.png",_="/assets/网络06-9c0077d0.png",k="/assets/网络07-a92c26e7.png",g="/assets/网络08-a5bcaac5.png",v="/assets/网络09-5446d2ee.png",f="/assets/网络10-e96154ac.png",x="/assets/网络11-8e6a9105.png",q="/assets/网络12-9424f49b.png",y="/assets/网络13-40a6910e.png",P="/assets/网络14-a8153074.png",w="/assets/网络15-7c91f5bd.png",T="/assets/网络16-4439f90b.png",A={},j=n('<blockquote><p>对于前端而言，网络部分代码不多，以概念为主</p><br><p>对概念的理解程度，决定了是否能够看懂接口文档，同时也决定了是否能更好的掌控网络相关代码</p></blockquote><h2 id="一-客户端和服务器" tabindex="-1"><a class="header-anchor" href="#一-客户端和服务器" aria-hidden="true">#</a> （一）客户端和服务器</h2><h3 id="_1-通信" tabindex="-1"><a class="header-anchor" href="#_1-通信" aria-hidden="true">#</a> 1.通信</h3><ul><li>在网络的世界里，两个应用程序之间会经常发生通信</li><li>在大部分情况下，通信总是由一方发出一个消息开始，而另一方回复一个消息结束</li><li>发出消息的一方称之为 <strong>客户端 Client</strong> ，发出消息的过程称之为 <strong>请求 Request</strong></li><li>回复消息的一方称之为 <strong>服务器 Server</strong>，回复消息的过程称之为 <strong>响应 Response</strong></li><li>一次完整的交互，总是从请求开始，响应结束</li></ul><p><img src="'+p+'" alt=""></p><h3 id="_2-特别注意" tabindex="-1"><a class="header-anchor" href="#_2-特别注意" aria-hidden="true">#</a> 2.特别注意</h3><ul><li>不管是客户端，还是服务器，都是一个 <strong>应用程序</strong>，而不是一台计算机</li><li>客户端和服务器可以分布在不同的计算机上，也可以在同一台计算机上，并不需要特殊看待 <ul><li>比如 live server 插件，就是一个服务器，运行在本地的计算机上</li></ul></li><li>大部分后端开发的就是服务器程序，前端的 Node 技术也能开发服务器程序</li></ul><h3 id="_3-c-s-b-s" tabindex="-1"><a class="header-anchor" href="#_3-c-s-b-s" aria-hidden="true">#</a> 3.C/S &amp; B/S</h3><ul><li>客户端和服务器的这种交互模式称之为 <strong>经典 C/S 结构</strong><ul><li>在这种结构中，如果客户端是浏览器，则我们称之为 <strong>B/S 结构</strong></li></ul></li><li>服务器程序往往是为互联网产品提供服务，因此又称之为 <strong>Web 服务器</strong></li></ul><h2 id="二-url" tabindex="-1"><a class="header-anchor" href="#二-url" aria-hidden="true">#</a> （二）URL</h2><ul><li>要完成一次请求和响应，首先需要让客户端找到服务器，还要在服务器上找到想要的资源 <ul><li>在现实生活中，如果要找一个人，可以通过一个地址来找到他</li><li>在互联网中，可以通过 <strong>URL 地址</strong> 找到想要的资源</li></ul></li><li>URL, Uniform Resource Locator，统一资源定位符</li><li>是一个字符串，用于表达互联网中某个资源的位置</li></ul><h3 id="_1-示例" tabindex="-1"><a class="header-anchor" href="#_1-示例" aria-hidden="true">#</a> 1.示例</h3><ul><li>百度首页的 url 地址 <ul><li>https://www.baidu.com/</li></ul></li><li>某篇新闻页面的 url 地址 <ul><li>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9610068257663826418%22%7D&amp;n_type=-1&amp;p_from=-1</li></ul></li><li>某知名 css 的 url 地址 <ul><li>https://meyerweb.com/eric/tools/css/reset/reset.css</li></ul></li><li>某知名 js 的 url 地址 <ul><li>https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js</li></ul></li><li>某张图片的 url 地址 <ul><li>https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F84%2F87%2F80%2F848780a296b66b382018fa7f675ecd06.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652600873&amp;t=803c81d81387ec5f9fd1d92ba9d7665a</li></ul></li></ul><h3 id="_2-特点" tabindex="-1"><a class="header-anchor" href="#_2-特点" aria-hidden="true">#</a> 2.特点</h3><ul><li>URL 地址可以很长，也可以很短</li><li>通过 URL 地址可以找到互联网上的资源 <ul><li>可以是页面、图片、视频、音频、css 代码、js 代码、可供下载的文件，或者其他任何东西</li></ul></li><li>URL 中不能出现非 ASCII 字符 <ul><li>只能出现数字、英文字母、英文标点符号</li><li>非 ASCII 字符会自动编码</li></ul></li></ul><h3 id="_3-组成" tabindex="-1"><a class="header-anchor" href="#_3-组成" aria-hidden="true">#</a> 3.组成</h3><ul><li>一个完整的 URL 地址由多个部分组成</li><li><code>协议 + 主机 + 端口 + 路径 + 参数 + hash</code></li></ul><p><img src="'+u+'" alt=""></p><h4 id="_1-协议-protocal-schema" tabindex="-1"><a class="header-anchor" href="#_1-协议-protocal-schema" aria-hidden="true">#</a> 1）协议 Protocal / Schema</h4><ul><li>表示客户端希望用什么方式和服务器沟通 <ul><li>一般为 http 或 https</li></ul></li><li>如果在浏览器的地址栏省略了协议，浏览器会自动补全 <ul><li>可以在 Chrome 浏览器的地址栏点击右键，显示完整的地址</li></ul></li><li>https 协议比 http 协议更安全 <ul><li>往往出现在线上</li><li>本地的服务器通常不会是 https</li></ul></li></ul><h4 id="_2-主机-host" tabindex="-1"><a class="header-anchor" href="#_2-主机-host" aria-hidden="true">#</a> 2）主机 Host</h4><ul><li>表示客户端希望在哪台计算机上寻找资源</li><li>有两种写法：IP 地址和域名</li><li>IP 地址 <ul><li>IP 地址是一个网络中计算机的唯一编号</li><li>通常，一个 IP 对应一台计算机</li></ul></li><li>域名 <ul><li>域名类似 IP 地址的别名，把不容易记忆的数字变为容易记忆的单词</li><li>当使用域名访问时，会自动转换为 IP 地址</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">记住</p><ul><li>特殊 IP 地址：<strong>127.0.0.1 表示本机 IP</strong></li><li>特殊域名：<strong>localhost 表示的 IP 地址是 127.0.0.1</strong></li></ul></div><h4 id="_3-端口-port" tabindex="-1"><a class="header-anchor" href="#_3-端口-port" aria-hidden="true">#</a> 3）端口 Port</h4><ul><li>表示客户端希望在哪个应用程序中寻找资源</li><li>每个服务器程序，都会监听一个或多个端口 <ul><li>只有找到对应的端口，才能找到这个服务器程序</li></ul></li><li><strong>端口号是可选的</strong>，若不填写： <ul><li>如果使用的是 <strong>HTTP</strong> 协议，默认端口号为 <strong>80</strong></li><li>如果使用的是 <strong>HTTPS</strong> 协议，默认端口号为 <strong>443</strong></li></ul></li></ul><h4 id="_4-路径-path" tabindex="-1"><a class="header-anchor" href="#_4-路径-path" aria-hidden="true">#</a> 4）路径 Path</h4><ul><li>服务器上往往有许许多多的资源，每个资源都有自己的访问路径</li><li><strong>路径是可选的</strong>，若不填写，则路径为 <code>/</code></li></ul><h4 id="_5-参数-query-param" tabindex="-1"><a class="header-anchor" href="#_5-参数-query-param" aria-hidden="true">#</a> 5）参数 Query / Param</h4><ul><li>某些资源可以根据需要呈现不同的内容 <ul><li>比如一篇新闻列表的页面，可以指定它呈现第几页的新闻</li><li>而 “第几页” 就属于一些额外信息，这些额外信息可以通过参数传递</li></ul></li><li>比如，访问一个新闻列表的页面，同时希望它展示第 5 页，每页展示 10 条新闻 <ul><li>可能会得到的 url 地址： <code>http://duyiedu.com/news?page=1&amp;limit=10</code></li><li><code>page=1&amp;limit=10</code> 就是参数部分，这部分可以包含多个参数</li><li>不同的参数之间使用 <code>&amp;</code> 分割</li></ul></li><li><strong>参数是可选的</strong></li></ul><h4 id="_6-hash" tabindex="-1"><a class="header-anchor" href="#_6-hash" aria-hidden="true">#</a> 6）hash</h4><ul><li>在网络通信中，hash 没有什么用</li><li>往往作为浏览器的 <strong>锚链接</strong> 出现</li></ul><h2 id="三-http" tabindex="-1"><a class="header-anchor" href="#三-http" aria-hidden="true">#</a> （三）HTTP</h2><ul><li>通过 url 地址，能够在茫茫互联网中准确的找到想要的服务 <ul><li>但光找到服务还是不够，双方需要 <strong>用同一种语言</strong> 来对话，否则都听不懂对方在说什么</li><li>这个语言就是协议，而互联网中最常见的协议就是 <strong>HTTP 协议</strong></li><li>https 是在 http 协议基础上发展起来的，增加了 <strong>安全性</strong> ，其他和 http 协议完全一致</li></ul></li><li>http 是基于 <strong>请求-响应</strong> 的方式完成通信的</li><li>每一次通信都是由客户端向服务器发出请求，传递一些消息过去，然后经过服务器程序处理后，响应给客户端一些消息</li></ul><h3 id="_1-http-协议规定" tabindex="-1"><a class="header-anchor" href="#_1-http-协议规定" aria-hidden="true">#</a> 1.HTTP 协议规定</h3><h4 id="_1-每次请求-响应都是-独立-的" tabindex="-1"><a class="header-anchor" href="#_1-每次请求-响应都是-独立-的" aria-hidden="true">#</a> 1）每次请求-响应都是 <strong>独立</strong> 的</h4><ul><li>相互之间互不干扰</li><li>这种模式的协议我们称之为 <strong>无状态协议</strong></li><li>http 的无状态会带来一些问题</li></ul><h4 id="_2-每次请求-响应传递的消息都是-纯文本-字符串" tabindex="-1"><a class="header-anchor" href="#_2-每次请求-响应传递的消息都是-纯文本-字符串" aria-hidden="true">#</a> 2）每次请求-响应传递的消息都是 <strong>纯文本（字符串）</strong></h4><ul><li>文本格式必须按照 http 协议规定的格式书写</li></ul><p><img src="'+h+'" alt=""></p><h3 id="_2-请求的消息格式" tabindex="-1"><a class="header-anchor" href="#_2-请求的消息格式" aria-hidden="true">#</a> 2.请求的消息格式</h3><p><img src="'+m+`" alt=""></p><ul><li>请求消息格式由三部分组成 <ul><li>请求行：高度概括了客户端想要干什么</li><li>请求头：描述了请求的一些额外信息</li><li>请求体：包含了要给服务器传递的正文数据</li></ul></li><li><strong>请求体是可以省略的</strong></li></ul><h3 id="_3-请求行" tabindex="-1"><a class="header-anchor" href="#_3-请求行" aria-hidden="true">#</a> 3.请求行</h3><ul><li>请求行是整个 http 报文的第一行字符串</li><li>包含三个部分 <ul><li><strong>请求方法</strong></li><li>路径 + 参数 + hash</li><li>协议和版本</li></ul></li><li>请求方法是一个单词，表达了客户端的动作 <ul><li>GET（获取资源）</li><li>POST（提交消息）</li><li>PUT（修改数据）</li><li>DELETE（删除数据）</li></ul></li><li>其中，GET 和 POST 最为常见</li></ul><blockquote><p>在 http 协议中，并没有规定只能使用上面两种动作</p><br><p>甚至没有规定每种动作会带来怎样的变化</p><br><p>而在实际的应用中，逐渐有了一些约定俗成的规范</p></blockquote><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>GET 和 DELETE 请求不能有请求体</li><li>POST 和 PUT 请求可以有请求体</li></ul></div><ul><li>浏览器遵循了上面的规范，这带来了 GET 和 POST 的诸多区别 <ul><li>比如，由于 GET 请求没有请求体，所以要传递数据只能把数据放到 url 的参数中</li></ul></li><li>在浏览器中，获取数据一般使用的都是 GET 请求 <ul><li>在地址栏输入地址并按下回车</li><li>点击了某个 a 元素</li><li>获取图片、音频、视频</li><li>获取 css、js、字体等文件</li></ul></li><li><strong>事实上，浏览器自动发出的请求基本都是 GET 请求</strong></li><li><strong>POST 请求需要开发者手动处理</strong><ul><li>比如在 form 表单中设置 method 为 POST</li></ul></li></ul><h3 id="_4-请求头-header" tabindex="-1"><a class="header-anchor" href="#_4-请求头-header" aria-hidden="true">#</a> 4.请求头 header</h3><ul><li>请求头是一系列的键值对，里面包含了诸多和业务无关的信息</li><li>浏览器每次请求服务器都会自动附带很多的请求头，其实这些请求头大部分服务器是不需要的</li></ul><h4 id="_1-host" tabindex="-1"><a class="header-anchor" href="#_1-host" aria-hidden="true">#</a> 1）Host</h4><ul><li>URL 地址中的主机</li></ul><h4 id="_2-user-agent" tabindex="-1"><a class="header-anchor" href="#_2-user-agent" aria-hidden="true">#</a> 2）User-Agent</h4><ul><li>客户端的信息描述</li></ul><h4 id="_3-content-type" tabindex="-1"><a class="header-anchor" href="#_3-content-type" aria-hidden="true">#</a> 3）Content-Type</h4><ul><li>请求体的消息是什么格式</li><li>如果没有请求体，这个字段无意义</li></ul><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>application/x-www-form-urlencoded</code></td><td>表示请求体的数据格式和 url 地址中参数的格式一样<br><code>loginId=admin&amp;loginPwd=123123</code></td></tr><tr><td><code>application/json</code></td><td>表示请求体的数据是 json 格式<br><code>{&quot;loginId&quot;: &quot;admin&quot;, &quot;loginPwd&quot;: &quot;123123&quot;}</code></td></tr><tr><td><code>multipart/form-data</code></td><td>一种特殊的请求体格式<br>上传文件一般选择该格式</td></tr></tbody></table><h3 id="_5-请求体-body" tabindex="-1"><a class="header-anchor" href="#_5-请求体-body" aria-hidden="true">#</a> 5.请求体 body</h3><ul><li>包含业务数据的字符串</li><li>理论上，请求体可以是任意格式的字符串</li><li>但习惯上，服务器普遍能识别以下格式</li></ul><table><thead><tr><th>值</th><th>字符串</th></tr></thead><tbody><tr><td><code>application/x-www-form-urlencoded</code></td><td>属性名=属性值&amp;属性名=属性值...</td></tr><tr><td><code>application/json</code></td><td>{&quot;属性名&quot;:&quot;属性值&quot;, &quot;属性名&quot;:&quot;属性值&quot;}</td></tr><tr><td><code>multipart/form-data</code></td><td>使用某个随机字符串作为属性之间的分隔符<br>通常用于文件上传</td></tr></tbody></table><ul><li>由于请求体格式的多样性，服务器在分析请求体时可能无法知晓具体的格式，从而不知道如何解析请求体</li><li>因此，服务器往往要求在请求头中附带一个属性 <code>Content-Type</code> 来描述请求体使用的格式</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Content-Type: application/x-www-form-urlencoded
Content-Type: application/json
Content-Type: multipart/form-data
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-响应的消息格式" tabindex="-1"><a class="header-anchor" href="#_6-响应的消息格式" aria-hidden="true">#</a> 6.响应的消息格式</h3><ul><li>服务器（通常由后端开发）收到请求的消息后，会运行后端代码对请求进行处理，处理完成后，会给予响应</li><li>服务器的响应格式包含三个部分</li></ul><p><img src="`+b+'" alt=""></p><h3 id="_7-响应行" tabindex="-1"><a class="header-anchor" href="#_7-响应行" aria-hidden="true">#</a> 7.响应行</h3><ul><li>响应行是整个响应字符串的第一行</li><li>包含两个部分 <ul><li>协议版本</li><li><strong>状态码、状态消息</strong></li></ul></li></ul><h4 id="_1-协议版本" tabindex="-1"><a class="header-anchor" href="#_1-协议版本" aria-hidden="true">#</a> 1）协议版本</h4><ul><li>表示服务器打算和客户端用什么协议通信</li></ul><h4 id="_2-状态码、状态消息" tabindex="-1"><a class="header-anchor" href="#_2-状态码、状态消息" aria-hidden="true">#</a> 2）状态码、状态消息</h4><ul><li>表示服务器对当前请求的表态</li><li>通常，状态码和状态消息是一一对应的 <ul><li>比如状态码 200 的消息就是 OK</li></ul></li><li>不同的请求可能会得到不同的状态码 <ul><li>至于到底会得到哪个状态码，由后端程序决定</li></ul></li><li>状态码分为五类</li></ul><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">通常认为</p><p>0~399 之间的状态码都是正常的，其他是不正常的</p></div><ul><li>200 OK：一切正常</li></ul><blockquote><p>啥事没有</p></blockquote><ul><li>301 Moved Permanently：资源已被永久重定向</li></ul><blockquote><p>你的请求我收到了，但是呢，你要的东西不在这个地址了，我已经永远的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了响应头的 Location 中了</p></blockquote><ul><li>302 Found：资源已被临时重定向</li></ul><blockquote><p>你的请求我收到了，但是呢，你要的东西不在这个地址了，我临时的把它移动到了一个新的地址，麻烦你取请求新的地址，地址我放到了请求头的 Location 中了</p></blockquote><ul><li>304 Not Modified：文档内容未被修改</li></ul><blockquote><p>你的请求我收到了，你要的东西跟之前是一样的，没有任何的变化，所以我就不给你结果了，你自己就用以前的吧。啥？你没有缓存以前的内容，关我啥事</p></blockquote><ul><li>400 Bad Request：语义有误，当前请求无法被服务器理解</li></ul><blockquote><p>你给我发的是个啥啊，我听都听不懂</p></blockquote><ul><li>403 Forbidden：服务器拒绝执行</li></ul><blockquote><p>你的请求我已收到，但是我就是不给你东西</p></blockquote><ul><li>404 Not Found：资源不存在</li></ul><blockquote><p>你的请求我收到了，但我没有你要的东西</p></blockquote><ul><li>500 Internal Server Error：服务器内部错误</li></ul><blockquote><p>你的请求我已收到，但这道题我不会，解不出来，先睡了</p></blockquote><h3 id="_8-响应头-header" tabindex="-1"><a class="header-anchor" href="#_8-响应头-header" aria-hidden="true">#</a> 8.响应头 header</h3><ul><li>和请求头一样，响应头也是由很多个键值对组成的 <ul><li>具体有哪些键值对，完全取决于服务器程序</li></ul></li><li>最重要的键值对是 <code>Content-Type</code><ul><li>有多种取值，表示响应体的数据类型</li><li>在 B/S 模式中，浏览器会自动根据响应头中 <code>Content-Type</code> 的取值，决定如何处理响应体</li></ul></li></ul><table><thead><tr><th>值</th><th>处理</th></tr></thead><tbody><tr><td><code>text/plain</code></td><td>普通的纯文本<br>浏览器通常会将响应体原封不动的显示到页面上</td></tr><tr><td><code>text/html</code></td><td>html 文档<br>浏览器通常会将响应体作为页面进行渲染</td></tr><tr><td><code>text/javascript</code> 或<br><code>application/javascript</code></td><td>js 代码<br>浏览器通常会使用 JS 执行引擎将它解析执行</td></tr><tr><td><code>text/css</code></td><td>css 代码<br>浏览器会将它视为样式</td></tr><tr><td><code>image/jpeg</code></td><td>图片资源<br>浏览器会将它视为 jpg 图片</td></tr><tr><td><code>attachment</code></td><td>附件<br>浏览器看到这个类型，通常会触发下载功能</td></tr><tr><td>其他 <code>MIME</code> 类型</td><td></td></tr></tbody></table><h3 id="_9-响应体-body" tabindex="-1"><a class="header-anchor" href="#_9-响应体-body" aria-hidden="true">#</a> 9.响应体 body</h3><ul><li>响应的主体内容</li></ul><h2 id="四-浏览器页面处理流程" tabindex="-1"><a class="header-anchor" href="#四-浏览器页面处理流程" aria-hidden="true">#</a> （四）浏览器页面处理流程</h2><ul><li>当在浏览器地址栏中输入一个 url 地址，并按下回车后，会发生什么？</li></ul>',95),I=n('<p><img src="'+_+`" alt=""></p><h2 id="五-ajax" tabindex="-1"><a class="header-anchor" href="#五-ajax" aria-hidden="true">#</a> （五）AJAX</h2><ul><li>AJAX 就是浏览器赋予 JS 的一套 API</li><li>通过这套 API 能够使 JS 具备网络通信的能力</li></ul><h3 id="_1-历史" tabindex="-1"><a class="header-anchor" href="#_1-历史" aria-hidden="true">#</a> 1.历史</h3><h4 id="_1-诞生" tabindex="-1"><a class="header-anchor" href="#_1-诞生" aria-hidden="true">#</a> 1）诞生</h4><ul><li>浏览器本身就具备网络通信的能力，但在早期，浏览器并没有把这个能力开放给 JS</li><li>最早是微软在 IE 浏览器中把这一能力向 JS 开放，让 JS 可以在代码中实现发送请求</li><li>这项技术在 2005 年被正式命名为 AJAX，Asynchronous Javascript And XML</li></ul><h4 id="_2-成形" tabindex="-1"><a class="header-anchor" href="#_2-成形" aria-hidden="true">#</a> 2）成形</h4><ul><li>IE 使用了一套 API 来完成请求的发送 <ul><li>这套 API 主要依靠一个构造函数完成</li></ul></li><li>该构造函数的名称为 <code>XMLHttpRequest</code><ul><li>简称为 <code>XHR</code> ，所以这套 API 又称之为 <code>XHR API</code></li></ul></li></ul><h4 id="_3-进阶" tabindex="-1"><a class="header-anchor" href="#_3-进阶" aria-hidden="true">#</a> 3）进阶</h4><ul><li>由于 <code>XHR API</code> 有着诸多缺陷，在 HTML5 和 ES6 发布之后，产生了一套更完善的 API 来发送请求</li><li>这套 API 主要使用的是一个叫做 <code>fetch</code> 的函数 <ul><li>因此这套 API 又称之为 <code>Fetch API</code></li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>无论是 XHR 还是 Fetch，都是实现 ajax 的技术手段，只是 API 不同</p></div><h3 id="_2-xhr-api" tabindex="-1"><a class="header-anchor" href="#_2-xhr-api" aria-hidden="true">#</a> 2.XHR API</h3><h4 id="_1-xhr-readystate" tabindex="-1"><a class="header-anchor" href="#_1-xhr-readystate" aria-hidden="true">#</a> 1）xhr.readyState</h4><ul><li>一个数字</li><li>用于判断请求到了哪个阶段</li></ul><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>刚刚创建好了请求对象<br>但还未配置请求（未调用 open 方法）</td></tr><tr><td>1</td><td>open 方法已被调用</td></tr><tr><td>2</td><td>send 方法已被调用</td></tr><tr><td>3</td><td>正在接收服务器的响应消息体</td></tr><tr><td>4</td><td>服务器响应的所有内容均已接收完毕</td></tr></tbody></table><h4 id="_2-xhr-responsetext" tabindex="-1"><a class="header-anchor" href="#_2-xhr-responsetext" aria-hidden="true">#</a> 2）xhr.responseText</h4><ul><li>获取服务器响应的消息体文本</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 创建发送请求的对象</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当请求状态发生改变时运行的函数</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取响应头Content-Type</span>
  xhr<span class="token punctuation">.</span><span class="token function">getResponseHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 配置请求</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;请求方法&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;url地址&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置请求头</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 构建请求体，发送到服务器，如果没有请求体，传递null</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;请求体内容&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-fetch-api" tabindex="-1"><a class="header-anchor" href="#_3-fetch-api" aria-hidden="true">#</a> 3.Fetch API</h3><ul><li>fetch 会返回一个 Promise</li><li>该 Promise 会在接收完响应头后变为 fulfilled</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> resp <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;url地址&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 请求配置对象，可省略，省略则所有配置为默认值</span>

  <span class="token comment">// 默认为GET</span>
  <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">&quot;请求方法&quot;</span><span class="token punctuation">,</span>
  <span class="token comment">// 请求头配置</span>
  <span class="token literal-property property">headers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">&quot;Content-Type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;application/json&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 请求体</span>
  <span class="token literal-property property">body</span><span class="token operator">:</span> <span class="token string">&quot;请求体内容&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取响应头对象</span>
resp<span class="token punctuation">.</span>headers<span class="token punctuation">;</span>
<span class="token comment">// 获取响应状态码，例如200</span>
resp<span class="token punctuation">.</span>status<span class="token punctuation">;</span>
<span class="token comment">// 获取响应状态码文本，例如OK</span>
resp<span class="token punctuation">.</span>statusText<span class="token punctuation">;</span>
<span class="token comment">// 用json的格式解析即将到来的响应体，返回Promise，解析完成后得到一个对象</span>
resp<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 用纯文本的格式解析即将到来的响应体，返回Promise，解析完成后得到一个字符串</span>
resp<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container danger"><p class="hint-container-title">特别注意</p><p>无论使用哪一种 API，AJAX 始终都是异步的</p><blockquote><p>在初学的时候，可以把网络传输的时间想象的夸张一点</p><br><p>比如每一次请求和响应都要经过一年才能完成</p><br><p>这样有助于理解网络是异步这一点</p></blockquote></div><h2 id="六-postman" tabindex="-1"><a class="header-anchor" href="#六-postman" aria-hidden="true">#</a> （六）PostMan</h2>`,23),S={href:"https://www.postman.com/downloads/",target:"_blank",rel:"noopener noreferrer"},R=n('<h3 id="_1-跨域错误" tabindex="-1"><a class="header-anchor" href="#_1-跨域错误" aria-hidden="true">#</a> 1.跨域错误</h3><p><img src="'+k+'" alt=""></p><ul><li>这个错误通常发生在 AJAX 请求的时候，是一个跨域错误</li></ul><h4 id="_1-跨域" tabindex="-1"><a class="header-anchor" href="#_1-跨域" aria-hidden="true">#</a> 1）跨域</h4><ul><li>浏览器为了安全，制定了一个规则 <ul><li>即 <strong>页面的源和请求目标的源应该保持一致</strong></li><li>如果不一致，就产生了跨源或者叫跨域</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>源 = 协议 + 主机 + 端口</p></div><table><thead><tr><th>页面源</th><th>目标源</th><th>是否跨域</th></tr></thead><tbody><tr><td>https://baidu.com/news.html</td><td>http://103.231.13.42/1.jpg</td><td>是</td></tr><tr><td>https://www.baidu.com/news.html</td><td>http://baidu.com:8080/1.jpg</td><td>是</td></tr><tr><td>https://baidu.com/news.html</td><td>https://baidu.com/1.jpg</td><td>否</td></tr></tbody></table><h4 id="_2-同源策略" tabindex="-1"><a class="header-anchor" href="#_2-同源策略" aria-hidden="true">#</a> 2）同源策略</h4><ul><li><strong>浏览器对跨域行为作出的不同限制，统称为同源策略</strong><ul><li>浏览器对 img、link、script 的限制比较宽松，一般允许跨域</li><li>浏览器对 AJAX 比较严格，一般不允许跨域</li></ul></li><li>如果在 AJAX 中出现跨域请求，就会报出以上错误</li><li>但如果服务器明确告知浏览器允许跨域，则浏览器会允许 AJAX 跨域请求</li></ul><h3 id="_2-404-错误" tabindex="-1"><a class="header-anchor" href="#_2-404-错误" aria-hidden="true">#</a> 2.404 错误</h3><p><img src="'+g+'" alt=""></p><ul><li>浏览器请求某个资源，但服务器响应了一个 404 状态码，就会在控制台中报出这个错误 <ul><li>可以在浏览器的网络调试中进一步观察到这个错误</li></ul></li><li>404 错误是一种非常常见的错误 <ul><li>表示服务器告诉客户端：你要的资源并不存在</li></ul></li><li>要解决这个错误，首先要检查请求的 url 地址是否正确 <ul><li>如果 url 地址正确，则可能是服务器的问题，需要联系后端开发人员或者将问题上报</li></ul></li></ul><h4 id="_1-favicon" tabindex="-1"><a class="header-anchor" href="#_1-favicon" aria-hidden="true">#</a> 1）favicon</h4><p><img src="'+v+'" alt=""></p><ul><li>报错内容 <ul><li>加载资源失败：服务器响应了 404 状态码</li></ul></li><li>请求地址 <ul><li><code>:5500/favicon.ico</code></li></ul></li><li>原因 <ul><li>很多浏览器在解析页面后，如果发现页面中并没有使用 <code>link</code> 元素加载站点图标</li><li>会尝试请求以下地址来获取图标：<code>站点协议://站点主机:站点端口/favicon.ico</code></li><li>如果这个地址无法获得图标，就会报出相应错误</li></ul></li><li>该错误会在下一次刷新后消失，是因为再次刷新后，浏览器记忆了之前无法获取图标的情况，就不再发出请求了（缓存）</li></ul><h4 id="_2-其他问题" tabindex="-1"><a class="header-anchor" href="#_2-其他问题" aria-hidden="true">#</a> 2）其他问题</h4><p><img src="'+f+'" alt=""></p><blockquote><p>网络断开，检查你的网络连接，或者检查你是否在调试工具中进行了网络断开调试</p></blockquote><p><img src="'+x+'" alt=""></p><blockquote><p>访问的域名不存在，无法连接到服务器</p></blockquote><h2 id="七-关于-apifox-的使用" tabindex="-1"><a class="header-anchor" href="#七-关于-apifox-的使用" aria-hidden="true">#</a> （七）关于 Apifox 的使用</h2><ul><li>Apifox 是国内推出的一款类似于 postman 的接口测试工具</li></ul><h3 id="_1-安装-apifox" tabindex="-1"><a class="header-anchor" href="#_1-安装-apifox" aria-hidden="true">#</a> 1.安装 Apifox</h3>',23),E={href:"https://www.apifox.com/",target:"_blank",rel:"noopener noreferrer"},L=n('<h3 id="_2-加入团队" tabindex="-1"><a class="header-anchor" href="#_2-加入团队" aria-hidden="true">#</a> 2.加入团队</h3><p><img src="'+q+'" alt=""></p><h3 id="_3-测试接口" tabindex="-1"><a class="header-anchor" href="#_3-测试接口" aria-hidden="true">#</a> 3.测试接口</h3><h4 id="_1-第一种-服务器是由渡一直接部署到了云服务器上面" tabindex="-1"><a class="header-anchor" href="#_1-第一种-服务器是由渡一直接部署到了云服务器上面" aria-hidden="true">#</a> 1）第一种：服务器是由渡一直接部署到了云服务器上面</h4><ul><li>直接发送请求就可以拿到数据</li><li>比如【网络课程接口文档】，能够直接在 Apifox 发送请求拿到数据</li><li>发送请求时直接输入地址即可</li></ul><p><img src="'+y+'" alt=""></p><h4 id="_2-第二种-没有办法直接通过-apifox-发请求拿到数据的" tabindex="-1"><a class="header-anchor" href="#_2-第二种-没有办法直接通过-apifox-发请求拿到数据的" aria-hidden="true">#</a> 2）第二种：没有办法直接通过 Apifox 发请求拿到数据的</h4><ul><li>比如【博客】【个人空间】【织信人事管理系统】【coder station】</li><li>这些项目的服务器在对应的课件中是能够拿到的</li><li>需要在本地启动对应项目的服务器</li></ul><p><img src="'+P+'" alt=""></p><ul><li>针对这种类型的接口，如果没有启动本地的服务器</li><li>但是又想要快速的看一下响应对应有哪些字段</li><li>可以通过 mock 的形式</li></ul><p><img src="'+w+'" alt=""></p><ul><li>点击【快捷请求】后，对应的效果如下：</li></ul><p><img src="'+T+'" alt=""></p><h2 id="八-案例实操-聊天机器人" tabindex="-1"><a class="header-anchor" href="#八-案例实操-聊天机器人" aria-hidden="true">#</a> （八）案例实操：聊天机器人</h2><h3 id="_1-效果访问地址" tabindex="-1"><a class="header-anchor" href="#_1-效果访问地址" aria-hidden="true">#</a> 1.效果访问地址</h3>',15),C={href:"https://study.duyiedu.com/index.html",target:"_blank",rel:"noopener noreferrer"},H=n(`<h3 id="_2-test-http" tabindex="-1"><a class="header-anchor" href="#_2-test-http" aria-hidden="true">#</a> 2.test.http</h3><h4 id="_1-接口" tabindex="-1"><a class="header-anchor" href="#_1-接口" aria-hidden="true">#</a> 1）接口</h4><ul><li>POST</li><li>http://localhost:7001/api/user/login</li><li>HTTP/1.1</li></ul><h4 id="_2-请求头" tabindex="-1"><a class="header-anchor" href="#_2-请求头" aria-hidden="true">#</a> 2）请求头</h4><ul><li>content-type: application/json</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;loginId&quot;</span><span class="token operator">:</span> <span class="token string">&quot;haha&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;loginPwd&quot;</span><span class="token operator">:</span> <span class="token string">&quot;123123&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6);function X(F,J){const l=e("RouterLink"),s=e("ExternalLinkIcon");return r(),d("div",null,[j,a("blockquote",null,[a("p",null,[t("试试这个地址："),i(l,{to:"/notes/DuYi/01Basic/oss.duyiedu.com/test/index.html"},{default:c(()=>[t("oss.duyiedu.com/test/index.html")]),_:1})])]),I,a("ul",null,[a("li",null,[t("下载地址："),a("a",S,[t("https://www.postman.com/downloads/"),i(s)])])]),R,a("ul",null,[a("li",null,[t("官网下载："),a("a",E,[t("https://www.apifox.com/"),i(s)])])]),L,a("ul",null,[a("li",null,[a("a",C,[t("https://study.duyiedu.com/index.html"),i(s)])])]),H])}const B=o(A,[["render",X],["__file","11.html.vue"]]);export{B as default};
