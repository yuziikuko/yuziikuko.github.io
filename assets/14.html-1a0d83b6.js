import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as i,e as a}from"./app-c4ca78d8.js";const r={},l=a('<p>Vue 会监测 data 中<strong>所有层次</strong>的数据。</p><h2 id="_1-监测对象中的数据" tabindex="-1"><a class="header-anchor" href="#_1-监测对象中的数据" aria-hidden="true">#</a> 1.监测对象中的数据</h2><p>通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据。</p><ul><li><p>对象中后追加的属性，Vue 默认不做响应式处理。</p></li><li><p>如需给后添加的属性做响应式，请使用如下 API：</p><ul><li><p><code>Vue.set(target, propertyName / index, value)</code></p></li><li><p><code>vm.$set(target, propertyName / index, value)</code></p></li></ul></li></ul><h2 id="_2-监测数组中的数据" tabindex="-1"><a class="header-anchor" href="#_2-监测数组中的数据" aria-hidden="true">#</a> 2.监测数组中的数据</h2><p>通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><ul><li><p>调用原生对应的方法对数组进行更新。</p></li><li><p>重新解析模板，进而更新页面。</p></li></ul><h2 id="_3-特别注意" tabindex="-1"><a class="header-anchor" href="#_3-特别注意" aria-hidden="true">#</a> 3.特别注意</h2><p>在 Vue 修改数组中的某个元素一定要用如下方法：</p><ul><li><p>使用这些 API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()。</p></li><li><p>filter()不修改原数组，Vue 也监测不到，这类 API 则直接替换原数组即可。</p></li><li><p><code>Vue.set()</code>或<code>vm.$set()</code>不能给 <strong>vm</strong> 或 <strong>vm 的根数据对象</strong> 添加属性。</p></li></ul><h2 id="_4-数据劫持" tabindex="-1"><a class="header-anchor" href="#_4-数据劫持" aria-hidden="true">#</a> 4.数据劫持</h2><ul><li><p>Vue 中把 data 数据处理成<code>vm._data</code>的过程。</p></li><li><p>数据劫持和数据代理都离不开<code>Object.defineProperty()</code>。</p></li><li><p><strong>数据劫持才是响应式的根基</strong>。</p></li></ul>',12),o=[l];function p(d,s){return t(),i("div",null,o)}const h=e(r,[["render",p],["__file","14.html.vue"]]);export{h as default};
